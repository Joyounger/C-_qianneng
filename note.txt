ch11  类
protected与private的区别，在类的继承中才能表现出来

类名允许与其他变量名或函数名相同：
1 如果一个非类名隐藏了类名，则类名通过加class即可
2 如果一个类名隐藏了一个非类名，则用一般作用域规则即可


在函数中定义的类成为局部类，局部类的作用域在定义该类的函数块中。
局部类的成员函数必须在类定义内部定义，因为若在类外部和包含该类的函数内部中定义，则导致在函数内部定义函数的矛盾。如果在包含类的函数外部定义，则该局部类无法与其取得联系。


非类型：变量、常量、函数、对象、枚举成员

C++中类与非类型不在同一命名空间。也即在一个作用域中，一个名字可以声明为一个类型，又可声明为一个非类型。当两者同时登场时，类型名要加前缀class，以区分非类型名
‘
C+默认提供的构造函数是个无参构造函数，仅负责创建对象，不做任何初始化工作
与变量定义类似，在用默认构造函数创建对象时，如果创建的是全局对象或静态对象，则对象的位模式全为0,否则，对象是随机的。




由于分配数组时，new的格式是类型后面跟[元素个数]，不能再跟构造函数参数，所以从堆上分配对象数组，只能调用默认的构造函数，不能调用其他任何构造函数，如果该类没有默认构造函数，则不能分配对象数组。
delete[] pS中的[]是要

如果类需要析构函数来析构资源，则它也需要一个拷贝构造函数。因为通常对象是自动被析构的。如果需要一个自定义的析构函数7


由C++提供的默认拷贝构造函数只是对对象进行浅拷贝复制，如果对象的数据成员包括指向堆空间的指针，就不能使用这种拷贝方式，此时必须自定义拷贝构造函数，为创建的对象分配堆空间





ch15
静态数据成员在程序一开始运行时就必须存在，因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。这样它的空间分配


静态数据成员用的比较多的场合为
1 用来保存流动变化的对象个数
2 作为一个标志，指示一个特定的动作是否发生
3 一个指向一个链表第一成员或最后一个成员的指针


一个静态成员函数不与任何对象相联系，故不能对非静态成员进行默认访问
静态成员函数与非静态成员函数根本区别在于静态成员函数没有this指针



ch16
为了指明某个成员函数具有多态性，用关键字virtual来标志其为虚函数。
编译通常是在先期联编状态下工作的，只有看见虚函数才把它作为迟后联编来实现。如果虚函数在基类与子类中出现的仅仅是名字的相同，而参数类型不同，或返回类型不同，即使写上了virtual关键字，则也不进行迟后联编。

虚函数的限制：
2 静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。
3 内联函数不能时虚函数，因为内联函数不能在运行中动态确定其位置。即使虚函数在类的内部定义，编译时仍将其看作非内联的。
4 构造函数不能是虚函数，因为构造时对象还是一片未定型的空间。
5 析构函数可以是虚函数，而且通常生命为虚函数。




抽象类的唯一用途是被继承，一个抽象类至少具有一个纯虚函数
直到所有纯虚函数被重载之前，抽象类的子类也一直保持抽象状态。
不能创建一个抽象类的对象，但是可以声明一个抽象类的指针或引用。


ch17 多重继承
多重继承的构造顺序：构造对象的规则需要扩展以控制多重继承。构造函数按下列顺序调用：
1 任何虚拟基类的构造函数按照他们被继承的顺序构造
2 任何非虚拟基类的构造函数按照他们被继承的顺序构造
3 任何成员对象的构造函数按照它们声明的顺序调用
4 类自己的构造函数




